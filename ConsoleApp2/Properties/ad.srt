1
00:00:01-->00:00:03
 嗨，我是Jon Galloway，我是Jeff Fritz。
 2 
00:00:03-->00:00:06
 所以我们将在本次课程上谈论
3
00:00:06-->00:00:09
 中间件，自定义中间件，深入了解一些中间件。
4
00:00:09 -->00:00:13
是的，中间件感觉就像一个流行语
5
00:00:13-->00:00:16
但是，一旦我们越来越多深入了解ASP Net Core
6
00:00:16-->00:00:19
 我意识到一切都是中间件，这就是所有真正的力量所在
7
00:00:19-->00:00:23
 你知道吗，你配置的所有身份验证，MVC
00:00:23-->00:00:28
 所有你知道的与路由有联系的地方
00:00:28-->00:00:32
 而且很酷的是你可以使用中间件插件
00:00:32-->00:00:35
 它有很多原因，但有一个是你可以插入这个堆栈
00:00:35-->00:00:38
 是的，所以你可以说添加我的中间件
00:00:38-->00:00:42
 在此之前，我可以完全控制它，我可以调试它。
00:00:42-->00:00:45
 是的，我绝对可以自己写。
00:00:45-->00:00:47
 让我们来看看我们自己写的一些......好吧！
00:00:47-->0:00:53
 我的机器上有一个空的asp.net core应用程序
00:00:53-->00:00:57
 这只是配置了一些基础知识。
00:00:57-->00:01:00
 好吧。我的初始项目没有任何改进
00:01:00-->00:01:05
 我在这里有一个配置方法，然后我访问日志工厂
00:01:05-->00:01:08
 这样我才能创建一个日志。
00:01:08-->00:01:12
 因此，当我构建应用程序时，我可以开始与我的日志进行交互。
00:01:12-->00:01:14
 我做过的另一件事
00:01:14-->00:01:16
 我已经进入了我的项目
00:01:16-->00:01:22
 就像我在处理关于授权的视频时所做的那样
00:01:22-->00:01:26
 我在我的应用程序中激活了.net观察程序
00:01:26-->00:01:29
 通过添加此行DotNetCliToolReference
00:01:29-->00:01:32
 Microsoft DotNet Watcher工具2.0版本
00:01:32-->00:01:36
 这将让我重新运行我的应用程序。
00:01:36-->00:01:41
 每当在我的C#代码中有更改我将保存。
00:01:41-->00:01:48
 好。所以如果我现在运行这个应用程序，
00:01:48-->00:01:51
 我现在输入dotnet watch run
00:01:51-->00:01:54
 这将运行我的应用程序并开始观察
00:01:54-->00:01:57
 以确保如果有任何更改，它将会重新启动
00:01:57-->00:02:02
 它正在运行并且监听这个位置。
00:02:02-->00:02:06
 我复制并打开的浏览器
00:02:06-->00:02:10
 导航到那个位置，我得到，
00:02:10-->00:02:13
 Hello　World！现在我得到了Hello　World，
00:02:13-->00:02:17
 因为在这个配置方法中我配置了中间件
00:02:17-->00:02:21
 最后是这个应用程序运行
00:02:21-->00:02:27
 无论上下文是什么，我们都要将内容类型更改为HTML
00:02:27-->00:02:28
 我们将输出Hello　World
00:02:28-->00:02:32
 所以它 - 这非常棒，你完成这些只需要几行代码
00:02:32-->00:02:37
 你正在浏览网页请求 我正在用HTML提供网页请求
00:02:37-->00:02:41
 我想在这里指出的是这个运行语句
00:02:41-->00:02:43
 是一个正在终止的中间件。
00:02:43-->00:02:49
 好。发生这种情况后，我们实际上并没有传递给另一个项目
00:02:49-->00:02:53
 好。这是链条的终点，没有更多的事情发生
00:02:53-->00:02:57
 这通常是我们看到使用MVC时会看到的
00:02:57-->00:03:00
 在我们的中间件内部，这是一个终止件
00:03:00-->00:03:05
 即使它使用MVC
00:03:05-->00:03:09
 你可以继续做一些事后但是
00:03:09-->00:03:13
 按照惯例，运行说在此之后没有任何事情发生。
00:03:13-->00:03:15
 这是它的结束。好。
00:03:15-->00:03:18
 所以这是终止的。
00:03:18-->00:03:20
 还有其他东西，比如app.use 静态文件
00:03:20-->00:03:28
 所以如果有一些东西它不知道如何回应，它就会传递控制权
00:03:28-->00:03:32

00:03:32-->00:03:37
 所以，如果有人请求它在磁盘上找到一个静态文件，
00:03:37-->0:03:41
 它将提供该静态文件并停止处理。
00:03:41-->00:03:44
 在运行语句之前我把它放进去很重要
00:03:44-->00:03:49
 因为我想确保我们不总是得到一个Hello World。
00:03:49-->00:03:53
 当我为我的请求服务时有一个我写到了磁盘上index HTML，
00:03:53-->00:03:56
 只是从index.html输出Hello
00:03:56-->00:04:01
 如果我浏览到/index.html
00:04:01-->00:04:06
 我从index.html得到hello。如果我不去那个页面
00:04:06-->00:04:08
 如果我去别的地方
00:04:08-->00:04:12
 我仍然得到Hello World，所以你说的命令真的很重要
00:04:12-->00:04:16
 如果你的静态文件是在使用MVC之后。
00:04:16-->00:04:20
 让我们尝试，我使用Alt + Down将其向下移动
00:04:20-->00:04:24
 并把它放在我的运行声明之后。
00:04:24-->00:04:26
 现在我们回到浏览器
00:04:26-->00:04:30
 并且它说Hello World，当我请求index.html时
00:04:30-->00:04:34
 那是因为它知道是处理 index.html。
00:04:34-->00:04:38
 在它指定终止端点之后，
00:04:38-->00:04:39
 在那里打印Hello World。
00:04:39-->00:04:43
 这给了一定的能力和灵活性来证明这就是我们想要中间件处理程序。
00:04:43-->00:04:47

00:04:47-->00:04:59
 好吧，现在让我们回到这里，处理app.usestatic文件。
00:04:59-->00:05:03
 我们现在可以开始在这里编写自己的use语句来做其他事情了
00:05:03-->00:05:03
 这对我的管道很重要
00:05:06-->00:05:06
 我的请求管道。
00:05:11-->00:05:11
 所以，让我们在这里做些什么
00:05:14-->00:05:14
 将环境信息输出到我们的日志。
00:05:17-->00:05:17
 所以我会写app dot use，我可以在这里放一个匿名声明。
00:05:23-->00:05:23
 因此它实际上经过并在每个请求上执行此操作。
00:05:27-->00:05:32
 好的！因此我们需要的格式是使用异步某些上下文
00:05:32-->00:05:40
 然后下一个指示器指向下一个我们要求的特性。
00:05:40-->00:05:42

00:05:42-->00:05:47
 好的！好吧!现在我可以直接与管道进行交互当当它传递消息时
00:05:47-->00:05:53
 我将消息写入日志
00:05:53-->00:06:02
 我可以在这个EnvironmentName中开始请求
00:06:02-->00:06:08
 你做得很好，那将为我记录这些信息
00:06:08-->00:06:15
 当有一个请求所以我的编译完成后我会请求这个页面
00:06:15-->00:06:19
 它实际上没有返回任何东西。
00:06:19-->00:06:22
 但我正在写出我的开始请求声明。
00:06:22-->00:06:24
 它为什么不返回任何东西？
00:06:24-->00:06:29
 因为我的use语句是在有关HTTP上下文的信息中传递的
00:06:29-->00:06:32
 以及指向正在执行的下一个项目的指针
00:06:32-->
 所以你实际上需要告诉它。
00:06:36-->
 转到下一件事，好吧，让我们开始做它。
00:06:39-->
 所以现在我可以说等待下一步，它将执行管道中的下一个项目。
00:06:43-->
 所以我会保存，
00:06:48-->
 我会确保它在这里完成重启。
00:06:51-->
 当回到我的浏览器时，现在当我请求这个时，我从index.html得到Hello，因为这是管道中的下一个部分
00:06:55-->
 如果我在我的日志中查看这里
00:06:59-->
 我会得到开发中的开始请求
00:07:04-->
 然后我看到它服务于静态文件， 很棒！
00:07:06-->
 所以我们插入了一些信息，我们正在处理那个静态文件
00:07:12-->
 现在让我更进一步说明下一个语句正在执行，在其他事情完成后我仍然可以执行其他事情
00:07:19-->
 在其他事情完成后我仍然可以执行其他事情
00:07:20-->

00:07:23-->
 所以这很灵活性所以这让我可以灵活地呼叫他
00:07:25-->
  -- 调用他完成你将执行的中间件
00:07:29-->
 但在那之后我想要最后的决定权。 绝对的
00:07:32-->
 如果我在这里设置一个计时器，当我完成时，该怎么办？
00:07:36-->
 我可以记录日志信息，
00:07:41-->
 在那里它是，我可以说，当你正在打字，
00:07:45-->
 你正在使用最近添加到C＃的字符串插值功能
00:07:49-->
 我真的很喜欢那个开头的美元符号
00:07:52-->
 然后是花括号，
00:07:54-->
 它允许将代码插入字符串。是的，我可以格式化我的字符串
00:08:00-->
 无需使用那些基于整数的格式化语句。
00:08:03-->
 所以我只想输出信息
00:08:05-->
 关于完成请求需要多长时间。
00:08:08-->
 所以我将验证我的应用程序是否已完成重建
00:08:12-->
 并在这里重新开始，我将再次请求我的页面
00:08:17-->
 如果我查看我的日志，您可以在此处看到开发中的开始请求
00:08:22-->
 它服务于未修改的静态文件
00:08:25-->
 在9毫秒内完成了请求。
00:08:28-->
 我现在已经得到了所有这些信息，
00:08:32-->
 我可以通过编写一些中间件来插入和处理我的请求。
00:08:34-->

00:08:38-->
 现在这是一个used语句，used使用了上下文
00:08:42-->
 和下一个项目，所以它传递控制权
00:08:45-->
 我实际上最终包装了中间件
00:08:47-->
 而且我能够在重新启动时执行任务
00:08:51-->
 并解除请求，因为这些其他事情已经完成。
00:08:55-->
 现在，我可以在这里做其他事情，比如映射
00:08:00-->
 现在映射是我想分支请求的时候
00:09:03-->
 当某件事情发生时，我会做一些不同的事情
00:09:08-->
 当我满足某个标准时 
00:09:12-->
 好的，所以最简单的格式是匹配路径
00:09:18-->
 所以我可以匹配像联系人这样简单的东西
00:09:22-->
 如果有人请求联系人页面你想做什么？你想要什么？
00:09:28-->
 在这一点上，我可以传递
00:09:30-->
 类似的use或run语句。
00:09:33-->
 所以，让我们这样做，我将传递给run语句
00:09:38-->
 我会说，异步上下文，这次还有另一个打印
00:09:49-->
 这次我只是说等待上下文响应
00:09:53-->
 这里是异步的，你的联系人是正确的
00:10:00-->
 也许我有一些代码
00:10:01-->
 这将输出一些联系信息。
00:10:04-->
 好的，但我真的处于低水平的互动中
00:10:08-->
 该请求响应非常具体
00:10:10-->
 请求。是的，非常具体的格式，没有MVC在这里
00:10:15-->
 没有Razor视图，没有控制器，
00:10:18-->
 我正在直接针对该HTTP请求编写代码。
00:10:21-->
 好的，现在如果我进来的话
00:10:24-->
 我仍然可以请求index.html，我得到index.html
00:10:28-->
 但我有/Contacts的映射语句。
00:10:31-->
 所以，如果我去联系，
00:10:34-->
 我明白了。好的，对。
00:10:37-->
 如果我说联系人，我会去别的地方
00:10:39-->
 对于Jon来说，它在其他地方，
00:10:42-->
 它一直往下到那个运行
00:10:45-->
 它说Hello World！好的。
00:10:47-->
 所以现在我已经映射并跳转，因为我有匹配的路径
00:10:51-->
 我也可以在那里添加其他条件。
00:10:54-->
 所以看看这个。我们过去吧
00:10:56-->
 我想在这里再添加一些检查，
00:10:58-->
 我可以说app.Map何时和
00:11:02-->
 我可以在这里检查一个特定的条件。
00:11:05-->
 所以我将采取我的背景
00:11:08-->
 我要说上下文Request.Headers
00:11:13-->
 让我们检查我的用户代理
00:11:17-->
 因为也许我想对不同的浏览器采取不同的行为
00:11:20-->
 我可以说如果包含Firefox，
00:11:28-->
 好吧，我想说明别的事情要做。
00:11:33-->
 那么让我们创建一个Firefox 路由方法来调用
00:11:36-->
 打我将创建这个方法
00:11:40-->
 我会向下滚动到那个。
00:11:44-->
 所以这会收到一个IApplicationBuilder
00:11:47-->
 我将它重命名为app，
00:11:50-->
 在这种方法中，我现在可以做其他我想做的事情
00:11:53-->
 所以让我们调用app.Run
00:11:59-->
 我再一次处理上下文，
00:12:02-->
 当你输入时，我想到的一件事是因为你是
00:12:06-->
 你在这里展示你正在将这个重构到另一个
00:12:09-->
 在整个长的中间件列表中,你重构它到另一种方法，
00:12:15-->
 我甚至可以把它放到另一个程序集中
00:12:19-->
 我可以把它放到Nuget包中
00:12:22-->
 小心有雷！这就是我们接下来要做的事情。
00:12:25-->
 是的，让我们看看我需要异步，
00:12:30-->
 await不在那里， await goes over,
00:12:35-->
 是的，在这里。好的，所以现在我会保存它。
00:12:40-->
 所以看看这种情况发生的顺序。
00:12:43-->
 对。所以，如果跳转到contacts，
00:12:45-->
 我们要异步写，这是你的contacts。
00:12:48-->
 如果他们去了其他地方，他们正在使用Firefox，
00:12:52-->
 我们要写出Hello Firefox。好的。
00:12:55-->
 所以我会去/contacts，
00:12:58-->
 这是你的contacts。所以现在去别的地方，
00:13:02-->
 我得到了，Hello World！那我做错了什么？
00:13:07-->
 所以这就是发生了什么，让我备份
00:13:11-->
 让我们附加调试器并查看
00:13:14-->
 究竟是怎么回事。让我停止它，
00:13:17-->
 我会停止观看并转到我的代码
00:13:22-->
 现在，如果我在map上放置一个断点
00:13:25-->
 当声明，好的
00:13:28-->
 MapWhen实际上只在执行时才会出现在执行配置中
00:13:33-->

00:13:36-->
 启动基础。对！当此配置启动时，
00:13:40-->
 调试它们因为它没有按请求显示。居然！
00:13:44-->
 那么，让我在这里打个调试点，
00:13:48-->
 好的，我可以检查并查看header
00:13:51-->
 所以现在让我开始吧
00:13:53-->
 我的MiddleWare示例，这次我将使用Chrome浏览它。
00:13:57-->
 所以我可以看看这里发生了什么。
00:13:59-->
 好的，只是视图略有不同的。
00:14:02-->
 现在看我在MapWhen语句中点击了断点
00:14:05-->
 因为我正在配置它实际的Firefox路由尚未触发，
00:14:11-->
 好的。所以我会点击继续并逐步完成
00:14:15-->
 现在因为它请求它，我实际上是打破了这里的实际线路
00:14:20-->
  在我正在检查响应类型的地方
00:14:26-->
 让我们检查一下我的User-Agent标题
00:14:29-->
 所以，如果我看到oops错误的地方，
00:14:32-->
 Context.Requests.Headers。一旦你键入它，你可以放大右键。
00:14:39-->
 是的，我在瞬间做到这一点，我给大家展示一下
00:14:48-->
 header实际上是一个集合。
00:14:52-->
 哦，所以我需要看看集合中的第一个项目
00:14:55-->
 并检查那个字符串，好吧。所以，如果我说[0]
00:15:02-->
 它不会检查它
00:15:05-->
 如果我说First（），请为我评估，
00:15:07-->
 仍然不会让我遍历那个
00:15:09-->
 在这个窗口里面。那么让我在这里修改我的代码，
00:15:14-->
 所以我会改变这个说
00:15:17-->
 fisrst().Contains（“Firefox”）然后我们将路由
00:15:22-->
 到我的Firefox路线。按道理可以。
00:15:25-->
 所以让我再一次重新运行这个
00:15:32-->
 你是在Chrome浏览器中运行还是我想
00:15:35-->
 你可以选择你的浏览器。让我从chrome开始吧，好的
00:15:38-->
 所以现在这个正在运行
00:15:40-->
 我在Hello World这里停止！
00:15:44-->
 并且在Chrome内部运行，我得到了Hello World！
00:15:49-->
 好的。让我回到Firefox
00:15:52-->
 我会请求该位置，我得到了Hello Firefox。不错哦。
00:15:56-->
 好的，所以我通过检查用户代理字符串检测到了浏览器
00:16:00-->
 我已经映射了，我已经说过要在我的中间件中做这个
00:16:04-->
 。好吧，我在这张图中看到的一些更大的东西
00:16:06-->
 你是基于标题做的
00:16:08-->

00:16:09-->
 所以在这种情况下
00:16:11-->
 你检测的是用户代理
00:16:14-->
 但绝对可以检测到任何类型的标头
00:16:16-->
 关于请求的其他东西
00:16:18-->
 我认为另一件很酷的事情是我们不应该只是交叉的就是你可以调试它们
00:16:21-->
 这实际上是一些代码你可以进去设置断点你可以和它们互动
00:16:23-->
 你也可以设置有条件的事情
00:16:28-->
 如果我在开发中这样做
-->

00:16:30-->
 如果我正在写这个，不管它是否正确。绝对
00:16:33-->
 让我们这样做，
00:16:35-->
 让我们实际上写一下我们的例子
00:16:38-->
 我要停止这个，
00:16:42-->
 让我们把它移到另一个类中
00:16:45-->
 我们如何使用相同类型的静态文件
00:16:48-->
 让我们看看，
00:16:53-->
 我们是否可以在这里快速构建语法，
00:16:57-->
 围绕我们为环境信息所做的一些信息
00:17:00-->
 所以我能做的就是我可以在这里写另一堂课
00:17:05-->
 我将其称为EnvironmentMiddleware。
00:17:12-->
 那么让我们开始在这里创建一个类，
00:17:15-->
 公共类EnvironmentMiddleware现在关于中间件的事情是
00:17:20-->
 它不是一个抽象类或您正在实现的接口
00:17:23-->
 你实际上是在实现一种方法
00:17:26-->
 这很重要，那就是方法
00:17:28-->
 因此，让我们创建公共异步任务调用
00:17:32-->

00:17:33-->
 和Invoke采用HTTP上下文，我们只是将其称为上下文
00:17:39-->
 我要把我的的缩放放在这里再见。
00:17:44-->
 现在我的环境就像我一样
00:17:47-->
 记录有关环境的信息
00:17:49-->
 我想传递关于下一个委托的信息它将会出现在管道和宿主环境中
00:17:53-->

00:17:56-->
 所以让我用ctor片段创建一个构造函数
00:18:00-->
 我将接收RequestDelegate，通常是按照约定调用的
00:18:04-->

00:18:07-->
 然后是有关正在运行的托管环境的信息
00:18:10-->
 我把下一个委托保存到私有字段中
00:18:13-->

00:18:18-->
 我将为此创建一个只读字段
00:18:21-->
 然后我将保存我的环境信息
00:18:24-->
 进入另一个只读字段。cool！
00:18:29-->
 在我的调用中，我可以做几乎和之前在这个方法中做的一样的事情我直接复制粘贴到这里
00:18:32-->

00:18:34-->
 我可以做几乎和之前在这个方法中做的一样的事情我直接复制粘贴到这里
00:18:39-->

00:18:45-->
 我没有可用的日志
00:18:48-->
 所以让我们改变这一点
00:18:51-->
 让它更有互动性相对于那些没有访问日志的人
00:18:55-->

00:19:00-->
 我可以说明一些类似于上下文响应的东西。
00:19:02-->
 .Headers.Add
00:19:07-->
 然后添加关于HostingEnvironmentName的信息这是一个字符串集合。
00:19:09-->

00:19:17-->
 所以，新的字符串值是我要做的
00:19:21-->
 那里是一个匿名类型，还有EnvironmentName
00:19:26-->
 好吧，我只是将该环境名称添加为新标题
00:19:31-->
 自定义标头，这就是为什么有那个X.
00:19:34-->
 它不是，接下来是现在我没有日志
00:19:40-->
 但如果我能，那岂不是太好了
00:19:46-->
 哎呀！我没有将上下文传递给我们需要传递的下一个请求
00:19:50-->
 是的，这样，正在收听的行中的下一个人可以接收并与之交互
00:19:53-->

00:19:56-->
 因为我没有把它放在日志上
00:19:59-->
 我想把它放在一个页面上
00:20:01-->
 如果它是HTML。所以，让我们快速检查并说明我的环境名称是否等于Development，我
00:20:05-->
 也可以通过ISDevelopment和
00:20:12-->
 context.Response.ContentType等于text/html来做到这一点。
00:20:16-->

00:20:20-->

00:20:28-->
 哦! 我们还需要确保这一点
00:20:30-->
 ContentType不为null。ContentType不等于null。
00:20:37-->
 那么让我格式化一点。好吧，如果是的话
00:20:42-->
 如果是text/html，则不为null
00:20:45-->
 我们写出来了然后我们在HTML末尾加上context。response。writeasync
00:20:51-->

00:20:56-->
 我将添加一个带有一些字符串插值的段落从EnvironmentName中插入
00:21:05-->
 然后让我们完成我的timer.ElapsedMilliseconds。
00:21:11-->
 这非常酷，因此你正在修改HTML响应
00:21:15-->
 是的
00:21:18-->
 通过编写一些自定义中间件，绝对的。
00:21:21-->
 好吧所以我把它写成mix，
00:21:24-->
 这是一个异步调用所以我们应该await它
00:21:27-->
 好了，就是这样。这将在下一个语句之后触发。
00:21:32-->

00:21:35-->
 我会在chrome中运行我的Hello World!
00:21:43-->

00:21:47-->
 现在让我们来看看我们的标题信息
00:21:51-->
 那回来了。当我查看Localhost时，我会刷新一下。
00:22:04-->
 所以我还没有我的Header，那是因为我没有努力
00:22:07-->
 刷新此页面。
00:22:10-->
 它仍然在查看缓存的内容，所以我将点击localhost，
00:22:14-->
 现在它还没出来，
00:22:18-->
 我写了所有的类为什么它没有出来你实际上已经把它添加到管道中了
00:22:22-->
 那么我们如何将它添加到管道中呢
00:22:29-->
 我们有了这个using语句这里的use语句这是垃圾现在我们把它移到了另一个地方我们可以调用app
00:22:33-->
 现在我们已经将它移到我们可以说的其他地方
00:22:36-->
 UseMiddleware然后我喜欢在这里传递通用类型是的!EnvironmentMiddleware好
00:22:41-->

00:22:45-->
 好的。因此，通过该声明，让我们重新运行
00:22:49-->
 现在它在我们的管道中它被调用, 
00:22:53-->
 它在我们工作的过程中被引用现在它说-
00:22:55-->
 说从Development在22ms内
00:22:58-->
 如果我看看我的请求
00:23:02-->
 有我的Header X EnvironmentName，开发。
00:23:06-->
 它是为我写的，它也写在这个HTML页面中。
00:23:10-->
 它也没有在这里写，因为
00:23:17-->
 在我们的页面中发生的事情是，是的，中间件正在被调用，
00:23:22-->
 但是静态文件清除并且只返回它的内容
00:23:28-->
 所以本来会发生的事情正确地重新启动或被阻止
00:23:33-->
 因为它说我完成了响应，已经完成了它执行的Header
00:23:38-->
 并且在我的中间件中包含在下一个被调用之前已经完成
00:23:42-->
 但是因为剩下代码的被阻止
00:23:46-->
 它在此之后终止了这段代码
00:23:51-->

00:23:54-->
 别火，明白。是有意义的事情
00:23:59-->
 是啊！好吧，现在让我们做最后一件事
00:24:02-->
 这样我们就可以得到与使用静态文件相同的语法
00:24:06-->
 让我们在静态类中放入一个Quick Helper方法。
00:24:09-->
 让我猜猜你会怎么做
00:24:11-->
 我在这里讲话的时候让你打字，你一定要做
00:24:14-->
 你需要输入app.usemiddleware
00:24:16-->
 你需要给它一个通用的名字
00:24:20-->
 好的！但它有点烦躁
00:24:23-->
 并且它不如我在其他中间件中看到的那么好和经验。
00:24:26-->
 我正在连接我说的App.Use MVC，它为我自动完成，是的！
00:24:30-->
 你是对的，
00:24:35-->
 如果我也传入了自定义参数
00:24:38-->
 那也是我想要你的方法签名
00:24:40-->
 如果我需要传入很多东西来配置它也就是那个方法签名我可能想让你为我做一些工作使它更简单
00:24:43-->
 给我一些情报让它自动完成正确。
00:24:47-->
 我将使用相同的UseMiddleware环境中间件语句并嵌入到这里
00:24:51-->

00:24:54-->
 这样我就可以写其他代码了
00:24:58-->
 我需要用来在这里设置中间件。
00:25:03-->
 因此，现在在您的启动中，您可以用app.Use EnvironmentMiddleware替换UseMiddleware的代码
00:25:04-->

00:25:07-->
 就这样美丽！它仍然有用，
00:25:17-->
 我将从应用程序Hello World开始!从Development到24毫秒， 非常酷!
00:25:21-->
 所以这有点儿
00:25:22-->
 如何编写自定义中间件。
00:25:24-->
 我知道ASP.NET人员有一些例子供我们参考
00:25:28-->
 是啊！我只是想在这里展示一些示例，以供您深入编写自己的定制中间件时使用
00:25:32-->
 幸运的是，所有这些中间件都在Github上。
00:25:35-->
 幸运的是，所有这些中间件都在Github上。
00:25:38-->
 幸运的是，所有这些中间件都在Github上。
00:25:41-->
 所以在这里，我正在寻找BasicMiddleware repo，
00:25:45-->
 他们这里有好东西
00:25:47-->
 他们有一种类似于压缩各种压缩结果的方法。
00:25:53-->

00:25:57-->
 是啊！我想在这里展示的是中间件的重写，
00:26:01-->
 它的巧妙之处在于，，
00:26:04-->
 它允许你知道有mod重写重写规则
00:26:06-->
 您你可以把你的HT访问文件
00:26:10-->
 如果你在Apache上使用过，那就是一种通用语法。
00:26:14-->
 所以他们所做的，
00:26:17-->
 我认为非常巧妙的是他们已经创建了一些定制的中间件来解析这些并且用ASP.NET core
00:26:20-->

00:26:24-->
 这样一来，Kestrel现在就能理解我们在Apache上使用的相同规则了!
00:26:29-->
 非常酷！
00:26:32-->
 所以这里它可以理解如果这些只是重写规则
00:26:34-->

00:26:37-->
 你知道这是文本它也能理解这是他们的例子
00:26:40-->

00:26:43-->
 你可以添加这些重写
00:26:45-->
 你也可以在这里配置它们，这是相当酷!
00:26:50-->
 它完全理解我们过去使用的IIS重写规则。
00:26:54-->
 所以它也把这些都拉了进来，
00:26:58-->
 如果你看一下重写中间件本身，它是一些代码
00:27:02-->
 但它并不疯狂，这是一段代码，但并不疯狂你知道它不是成百上千行代码
00:27:07-->
 这是另一个类，
00:27:11-->
 然后开始与请求委托接下来就像我们在我的EnvironmentMiddleware中看到的那样
00:27:14-->
 它正在接受一些其他的东西，就像传入一个日志和选项等等
00:27:18-->
 在这里，他们设置了next和选项就像你做的一样然后他说了我的意思是这是几行代码
00:27:24-->

00:27:25-->
 但这不是我的酒吧不是压倒性的，
00:27:30-->
 所以在这里他们只是迭代规则和应用规则等等
00:27:33-->
 这是真的，
00:27:37-->
 然后在最后，就像你他们下次返回并传递联系人和委托
00:27:40-->
 真的很酷，
00:27:44-->
 然后他们也写了这些扩展方法
00:27:47-->
 所以我可以使用app.Use在这里我做app.UseRewriter
00:27:52-->
 所以我只是觉得这很像你想继续下去，
00:27:56-->
 因为你可能正在写一些超出你今天向我们展示的东西，
00:27:59-->
 这里有一些很好的样本和信息，
00:28:02-->
 关于如何做到另外一个我想要的地方。 请指出，
00:28:05-->
 中间件的文档是非常全面的。
00:28:09-->
 他们有一些很好的图表，
00:28:12-->
 解释你确切知道中间件是如何工作的，以及如何通过工作
00:28:16-->
 并解释了编写自己的自定义中间件的各种各样的事情！
00:28:19-->
 好吧，所以我们在这个视频中学到了很多关于中间件的知识
00:28:24-->
 了解了如何配置它为什么它的顺序很重要
00:28:27-->
 我们看到了如何让我们的中间件在外部类中编写它，
00:28:30-->
 我们可以在线编写它们，我们在Github上看到了一些很棒的示例
00:28:34-->
 非常感谢您加入我们这个视频。
00:28:38-->
 我们在这里为ASP.NET Core编写一些代码有很多乐趣。
00:28:42-->
 我希望你能加入我们下一个节目。
